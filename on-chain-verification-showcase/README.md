# Proof of Provenance: On-Chain Verification

## Summary

This is a demonstration of how the **VIMz** tool can be used to generate ZK proofs for image manipulation, which can then be verified **on-chain**, thanks to integration with the **Sonobe** library.

The showcase scenario involves two main actors:
- **Challenger**: Creates a challenge by publishing an image to IPFS and specifying a required transformation.
- **Solver**: Processes the image, applies the transformation, and generates a ZK proof of correctness using the VIMz tool.

A smart contract on an **EVM-based blockchain** governs the challenge. The solver submits their solution along with a ZK proof, and if the proof is valid, they receive a reward. The contract verifies the proof **on-chain** before approving the submission.

---

## Technical Details

### Contracts

#### Challenge Hub

The main contract is [`ChallengeHub.sol`](ChallengeHub.sol).
It acts as a registry for all challenges as described below.

- A challenge creator can call `createChallenge`, providing:
    - Source image ID (e.g., an IPFS identifier).
    - Proposed reward.
    - Required transformation.

- Once a challenge is published, solvers can submit their solutions by calling `submitSolution` with:
    - Challenge ID.
    - Solution image ID.
    - ZK proof of the transformation's validity.

The proof is verified **on-chain** using a **verifier contract** (see below).
The first solver to submit a valid solution receives the reward.

#### Verifier Contracts

Each transformation type has a **dedicated verifier contract**, generated by the **Sonobe** library.
Source codes are available in the [`verifier-contracts`](verifier-contracts/) directory.

### Image Registry

Since images are too large to be passed via calldata or stored on-chain, an off-chain storage solution is required.
This can be IPFS, Swarm, or any decentralized storage.

For this demo, a local IPFS node is used to store images.

### Off-Chain Tools

The off-chain components include:
- An image editor (a simple Python script).
- VIMz tool, used to generate ZK proofs, which are compatible with Sonobe verifiers.

All transformations are implemented as **Circom circuits**, located in the [`circuits`](../circuits/sonobe) directory.

---

## Deployment

All the contracts have been deployed to Aleph Zero EVM Testnet:
 - [ChallengeHub contract](https://evm-explorer-testnet.alephzero.org/address/0x5Bd9Bad14616C56a83f81e5888bCe48A2816E9B3?tab=contract)
 - [Blur verifier contract](https://evm-explorer-testnet.alephzero.org/address/0x65cC5C680994a53c0075A3AbDB6c93c9Abf743Db?tab=contract)
 - [Contrast verifier contract](https://evm-explorer-testnet.alephzero.org/address/0x25ba50DE21C502BCfb0e5889C8e565a8571D9d50?tab=contract)

The scenario has been run successfully on these contracts and corresponding transactions can be investigated:
 - [challenge creation](https://evm-explorer-testnet.alephzero.org/tx/0x8063ebb1beaa059ecafdba8c90ec8d485c1a98196c9a744a7841a325ac0332b8)
 - [solution submission](https://evm-explorer-testnet.alephzero.org/tx/0xbeab3cf18d6014dd5506dce36c285d2c2d78ca8a582eec6ce4554e501244969b)

In order to play with the contracts on your own, you can obtain TZERO (native token) using [faucet](https://drpc.org/faucet/alephzero).

---

## Running the scenario locally

### Requirements

1. You must be able to run VIMz tool together with its dependencies (like `Rust`, `Python3`, `Circom`, `Node`).
2. Foundry (https://book.getfoundry.sh/getting-started/installation).
3. IPFS (https://docs.ipfs.tech/install/command-line/).
4. Auxiliary tools like `jq`, `xxd`, `cut`.

You can check if you have all the necessary tools by running the following command:

```bash
./check-env.sh
```

In case you are missing some tools, the script will print out the instructions on how to install them.

### Launching the scenario

You can launch scenario by running `./scenario.sh`.
It will perform the following steps:
1. Check if all the required tools are available.
2. Install node dependencies (used in contract deployment).
3. Start a local Anvil node.
4. Build and deploy the contracts.
5. Create a challenge (upload an image to IPFS and create a challenge in the contract).
6. Solve the challenge (download the image, apply the transformation, generate a proof, and submit it to the contract).
7. Verify the solution on-chain and pay the reward.
8. Stop the Anvil node.

<details>
<summary>Example output</summary>

```
âœ… Checking requirements and installing dependencies
âœ… Anvil node started
âœ… Contracts deployed
ðŸš€ Creating challenge
  âœ… Challenge uploaded to IPFS with ID: QmRycz7eP5uzA2gjcjgGfFGE1Rou5p9jLamdfzgNR2k2ve
  âœ… Challenge created
ðŸš€ Solving challenge
  âœ… Found challenge ID: QmRycz7eP5uzA2gjcjgGfFGE1Rou5p9jLamdfzgNR2k2ve
  âœ… Challenge fetched from IPFS
  âœ… Image processed
  âœ… Solution uploaded to IPFS with ID: QmfW3ALNaPqG1gZ3jmAgAMEbe1uVKvGkTDpUv6tMYiuVyV

 ________________________________________________________
                                                         
 â–ˆâ–ˆ     â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   Verifiable  Image
 â–ˆâ–ˆ     â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆ    Manipulation from
  â–ˆâ–ˆ   â–ˆâ–ˆ   â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ     â–ˆâ–ˆ      Folded   zkSNARKs
   â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ                         
    â–ˆâ–ˆâ–ˆ     â–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ v1.4.0 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 ________________________________________________________
| Selected Backend: Sonobe
| Input file: "../on-chain-verification-showcase/blur.json"
| Output file: Some("../calldata/proof")
| Selected function: Blur
| Circuit file: "../circuits/sonobe/blur_step.r1cs"
| Witness generator: "../circuits/sonobe/blur_step_js/blur_step.wasm"
| Image resolution: HD
| Demo mode: true
 â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
 INFO Prepare input: 126ms
 INFO Prepare folding:Create circuit: 119ms
 INFO Prepare folding:Preprocess Nova: 2.66s
 INFO Prepare folding:Init Nova: 1.60s
 INFO Prepare folding: 4.38s
 INFO Fold input{steps=10}:Fold step{completed=0}: 1.86s
 INFO Fold input{steps=10}:Fold step{completed=1}: 1.62s
 INFO Fold input{steps=10}:Fold step{completed=2}: 1.97s
 INFO Fold input{steps=10}:Fold step{completed=3}: 1.99s
 INFO Fold input{steps=10}:Fold step{completed=4}: 1.99s
 INFO Fold input{steps=10}:Fold step{completed=5}: 1.99s
 INFO Fold input{steps=10}:Fold step{completed=6}: 1.95s
 INFO Fold input{steps=10}:Fold step{completed=7}: 1.98s
 INFO Fold input{steps=10}:Fold step{completed=8}: 1.99s
 INFO Fold input{steps=10}:Fold step{completed=9}: 1.99s
 INFO Fold input{steps=10}: 19.3s
 INFO Verify folded proof: 84.5ms
 INFO Prepare decider: 19.4s
 INFO Generate decider proof: 19.7s

  âœ… Proof computed
  âœ… Solution submitted
âœ… Scenario successfully run
âœ… Stopped running anvil node

```
</details>

### Observing the results

You can also connect some frontend explorer, like [Ethernal](https://tryethernal.com/), to the local node to see the transactions and the contract state.

Challenge creation event |  Solution submission event | Solution submission event (continued)
:-------------------------:|:-------------------------:|:-------------------------:
![create-challenge-event.png](screenshots/create-challenge-event.png)  |  ![submit-solution-1.png](screenshots/submit-solution-1.png) |![submit-solution-2.png](screenshots/submit-solution-2.png)
