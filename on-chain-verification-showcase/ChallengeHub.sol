// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ====================================== VERIFIER API =============================================================

interface ISnarkVerifier {
    function verifyNovaProof(
        uint256[9] calldata i_z0_zi,
        uint256[4] calldata U_i_cmW_U_i_cmE,
        uint256[2] calldata u_i_cmW,
        uint256[3] calldata cmT_r,
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[4] calldata challenge_W_challenge_E_kzg_evals,
        uint256[2][2] calldata kzg_proof
    ) external view returns (bool);
}

contract ChallengeHub {
    // ====================================== ASSOCIATED TYPES =========================================================

    /// @dev The type of transformation that the challenge is asking for.
    enum TransformationType {Blur, Contrast}

    /// @dev A challenge that a user can create and other users can solve.
    struct Challenge {
        /// @dev The address of the user who created the challenge.
        address creator;
        /// @dev The ID of the image that the challenge is asking for. For example, the IPFS hash.
        string imageID;
        /// @dev The type of transformation that the challenge is asking for.
        TransformationType transformationType;
        /// @dev The reward that the first solver will receive.
        uint256 reward;
        /// @dev Whether the challenge has been solved.
        bool solved;
    }

    // ====================================== STORAGE ==================================================================

    /// @dev The verifier contract for the blur transformation (generated by Sonobe).
    ISnarkVerifier public blurVerifier;
    /// @dev The verifier contract for the contrast transformation (generated by Sonobe).
    ISnarkVerifier public contrastVerifier;

    /// @dev The challenges that have been created.
    mapping(uint256 => Challenge) public challenges;
    /// @dev The number of challenges that have been created.
    uint256 public challengeCount;

    // ====================================== EVENTS ===================================================================

    /// @dev Emitted when a new challenge is created.
    event ChallengeCreated(
        uint256 challengeId,
        address creator,
        string imageID,
        TransformationType transformationType,
        uint256 reward
    );
    /// @dev Emitted when a challenge is solved.
    event ChallengeSolved(uint256 challengeId, address solver, uint256 reward, string solutionID);

    // ====================================== METHODS ==================================================================

    constructor(
        ISnarkVerifier _blurVerifier,
        ISnarkVerifier _contrastVerifier
    ) {
        blurVerifier = _blurVerifier;
        contrastVerifier = _contrastVerifier;
    }

    /// @dev Creates a new challenge. The caller must provide a reward deposit.
    function createChallenge(string memory _imageID, TransformationType _transformationType) external payable {
        require(msg.value > 0, "Must provide a reward deposit");

        challenges[challengeCount] = Challenge({
            creator: msg.sender,
            imageID: _imageID,
            transformationType: _transformationType,
            reward: msg.value,
            solved: false
        });

        emit ChallengeCreated(challengeCount, msg.sender, _imageID, _transformationType, msg.value);
        challengeCount++;
    }

    /// @dev Returns the ID of the image that a challenge is asking for.
    function imageId(uint256 challengeId) external view returns (string memory) {
        return challenges[challengeId].imageID;
    }

    /// @dev Solves a challenge by submitting a solution. The caller must provide a valid proof.
    function submitSolution(
        uint256[9] calldata i_z0_zi,
        uint256[4] calldata U_i_cmW_U_i_cmE,
        uint256[2] calldata u_i_cmW,
        uint256[3] calldata cmT_r,
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[4] calldata challenge_W_challenge_E_kzg_evals,
        uint256[2][2] calldata kzg_proof,
        uint256 challengeId,
        string memory solutionID
    ) external {
        Challenge storage challenge = challenges[challengeId];
        require(!challenge.solved, "Challenge already solved");

        ISnarkVerifier verifier;
        if (challenge.transformationType == TransformationType.Blur) {
            verifier = blurVerifier;
        } else {
            verifier = contrastVerifier;
        }

        bool isValid = verifier.verifyNovaProof(
            i_z0_zi,
            U_i_cmW_U_i_cmE,
            u_i_cmW,
            cmT_r,
            pA,
            pB,
            pC,
            challenge_W_challenge_E_kzg_evals,
            kzg_proof
        );
        require(isValid, "Invalid proof");

        challenge.solved = true;

        uint256 reward = challenge.reward;
        challenge.reward = 0; // Prevent reentrancy
        (bool success,) = msg.sender.call{value: reward}("");
        require(success, "Reward transfer failed");

        emit ChallengeSolved(challengeId, msg.sender, reward, solutionID);
    }
}
