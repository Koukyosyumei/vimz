use ark_bn254::{constraints::GVar, Bn254, Fr, G1Projective as G1};
use ark_groth16::Groth16;
use ark_grumpkin::{constraints::GVar as GVar2, Projective as G2};
use rand::{CryptoRng, RngCore};
use sonobe::{
    commitment::{kzg::KZG, pedersen::Pedersen},
    folding::nova::decider_eth::Decider as DeciderEth,
    frontend::circom::CircomFCircuit,
    Decider as DeciderTrait,
};

use crate::{
    sonobe_backend::folding::{Folding, FoldingParams},
    time::measure,
};

/// Compressed proof producer.
pub type Decider = DeciderEth<
    G1,
    GVar,
    G2,
    GVar2,
    CircomFCircuit<Fr>,
    KZG<'static, Bn254>,
    Pedersen<G2>,
    Groth16<Bn254>,
    Folding,
>;

pub type DeciderProverParam =
    <Decider as DeciderTrait<G1, G2, CircomFCircuit<Fr>, Folding>>::ProverParam;
pub type DeciderVerifierParam =
    <Decider as DeciderTrait<G1, G2, CircomFCircuit<Fr>, Folding>>::VerifierParam;
pub type DeciderProof = <Decider as DeciderTrait<G1, G2, CircomFCircuit<Fr>, Folding>>::Proof;

/// Prepare the Decider for the given folding scheme and parameters.
pub fn prepare_decider(
    folding: Folding,
    folding_params: FoldingParams,
    rng: &mut (impl RngCore + CryptoRng),
) -> (DeciderProverParam, DeciderVerifierParam) {
    let (decider_pp, decider_vp) = measure("Decider preprocess", || {
        Decider::preprocess(&mut *rng, &folding_params, folding).unwrap()
    });

    (decider_pp, decider_vp)
}

/// Verify the final proof generated by the folding scheme and the decider wrapper.
pub fn verify_final_proof(
    proof: &DeciderProof,
    folding: &Folding,
    decider_vp: DeciderVerifierParam,
) {
    assert!(Decider::verify(
        decider_vp,
        folding.i,
        folding.z_0.clone(),
        folding.z_i.clone(),
        &folding.U_i,
        &folding.u_i,
        proof,
    )
    .expect("Failed to verify proof"))
}
